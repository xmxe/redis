#### 介绍

| name                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [redis-delayqueue](https://github.com/xmxe/redis/tree/master/redis-delayqueue) | [base-redis-delay](https://gitee.com/daifyutils/springboot-samples/blob/master/base-redis-delay) <br>[Spring Boot + Redis实现延时队列](https://mp.weixin.qq.com/s/7hUHW7rwnJY7XCM0JFDXpQ) |
| [redis-distributedlock](https://github.com/xmxe/redis/tree/master/redis-distributedlock) | [Spring Boot + Redis实现分布式锁](https://mp.weixin.qq.com/s/PR1wJfjKOMsd8YI4Akf2ig) |
| [redis-resubmit](https://github.com/xmxe/redis/tree/master/redis-resubmit) | [SpringBoot + Redis解决海量重复提交问题](https://mp.weixin.qq.com/s/Ghd4Sk6vuufRiURoFS_lCA) |
| [redis-stock](https://github.com/xmxe/redis/tree/master/redis-stock) | [基于redis实现扣减库存的具体实现](https://www.jianshu.com/p/76bc0e963172) |
| [redis-subscribe](https://github.com/xmxe/redis/tree/master/redis-subscribe) | [Spring Boot中使用Redis的发布订阅功能](https://mp.weixin.qq.com/s/cRW1EXVzoz3aP-0rZH6Z9Q) |
| [redis-websocket](https://github.com/xmxe/redis/tree/master/redis-websocket) | [Redis解决websocket在分布式场景下session共享问题](https://mp.weixin.qq.com/s/kzf7hCmih3ix2yotjQCx5Q) |
| [redis-searchfilter](https://github.com/xmxe/redis/tree/master/redis-searchfilter) | [springboot java+redis 实现简单实用的搜索栏热搜功能，不雅文字过滤功能。](https://mp.weixin.qq.com/s/MN172c64M7MWN57kTXHIgg) |
| [redis-star](https://github.com/xmxe/redis/tree/master/redis-star) | [基于redis的点赞功能的实现](https://blog.csdn.net/qq_37618461/article/details/103821433) |
| [redis-limitanno](https://github.com/xmxe/redis/tree/master/redis-limitanno) | [Redis做接口限流，一个注解的事！](https://mp.weixin.qq.com/s/rzz2tgBBJpWz7gjmEfz2XQ) |
| [redis-limitInterceptor](https://github.com/xmxe/redis/tree/master/redis-limitInterceptor) | [几行代码，搞定SpringBoot接口恶意刷新和暴力请求！](https://mp.weixin.qq.com/s/yKjRTWTt_5NAFLefrf-Ntw) |



#### Redis命令

- [Reds命令（key、string）](https://blog.csdn.net/weixin_44626569/article/details/90046582)
- [Redis命令（hash、list）](https://blog.csdn.net/weixin_44626569/article/details/90108890)
- [Redis命令（set、zset）](https://blog.csdn.net/weixin_44626569/article/details/90178202)
- [Redis命令（hyperloglog、发布订阅、事务、脚本）](https://blog.csdn.net/weixin_44626569/article/details/90210347)
- [Redis命令（连接、服务器）](https://blog.csdn.net/weixin_44626569/article/details/90244145)




#### Redis知识点

- [Redis学习笔记一 简介](https://blog.csdn.net/weixin_44626569/article/details/89970593)
- [Redis学习笔记二 基础](https://blog.csdn.net/weixin_44626569/article/details/90043210)
- [你还不了解Redis的发布/订阅功能与Redis的Stream吗](https://mp.weixin.qq.com/s/wjThHZT1edWmn31YZP9U7Q)
- [妈妈再也不担心我面试被Redis问得脸都绿了](https://mp.weixin.qq.com/s/A8qQiLwE10j-eC_K8ylvzw)
- [Redis面试知识点总结！](https://mp.weixin.qq.com/s/KCBk_XYarpoEgW_QpBkLYg)
- [这40道Redis面试题让你不再慌（附答案）](https://mp.weixin.qq.com/s/hGJJz5yCtfRkfccG9nYNjw)
- [Redis夺命十二问，你能扛到第几问](https://mp.weixin.qq.com/s/bWBFcCnoJ05zSQe8_pNCig)
- [Redis最佳实践：7个维度+43条使用规范，带你彻底玩转Redis](https://mp.weixin.qq.com/s/5m8RwxxxRS2QPyRn4uSaCQ)
- [使用Redis，你必须知道的21个注意要点](https://mp.weixin.qq.com/s/BaZWxYfIR7HsRB3A_sVkHA)
- [从应用到底层36张图带你进入Redis世界](https://mp.weixin.qq.com/s/WqdOIqz46A5Af72J_Jkk8g)
- [Redis规范你应该了解一下](https://mp.weixin.qq.com/s/jxLS1QZGio55Mk078VTL0g)
- [看完后，我才明白Redis为什么默认16个数据库](https://mp.weixin.qq.com/s/Z5eBUHe62K6t_APgc6PTYQ)
- [手写Redis服务端，从设计者的角度聊一聊Redis本身](https://mp.weixin.qq.com/s/5lNDbc9h1u2jlGfRwaVW6A)
- [一口气说出Redis16个常见使用场景!](https://mp.weixin.qq.com/s/rhAEA2FHERXdyVeFbhQuSQ)
- [面试官：大量请求Redis不存在的数据，从而打倒数据库，你有什么方案？](https://mp.weixin.qq.com/s/soF3F8YYSbynK2lyofGMAg)
- [Redis是如何保证高效查询的？](https://mp.weixin.qq.com/s/xEYKp5ORPOFDXip6rmjqnQ)
- [Redis为什么变慢了？一文讲透如何排查Redis性能问题|万字长文](https://mp.weixin.qq.com/s/s0hgRS2bmnYszA9OJxz56Q)
- [Redis突然变慢了如何排查并解决？](https://mp.weixin.qq.com/s/6uUig_SXqiG3ZR7lyHZQDw)


##### 为什么是单线程
- [Redis为什么用单线程模型？终于知道了！](https://mp.weixin.qq.com/s/SlHBKlfF6qlXde_83dM5Ug)
- [为什么Redis单线程却能支撑高并发？](https://mp.weixin.qq.com/s/SunQ8BJjFfujNSEnqyWqpQ)
- [深度解析单线程的Redis如何做到每秒数万QPS的超高处理能力！](https://mp.weixin.qq.com/s/4bSy5cld0oZg8gqNGuemZA)
- [Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了](https://mp.weixin.qq.com/s/SYUYvKCxsyMbdBsRrJOZqA)
- [面试：Redis新版本开始引入多线程，谈谈你的看法？](https://mp.weixin.qq.com/s/YYrCeIEXHhSk7X4frU_oDg)
- [Redis新特性篇：多线程模型解读](https://mp.weixin.qq.com/s/XP-7CJ3OHxIiYg222wNVEg)

##### 数据结构
- [面试官：有一种数据类型，Redis要存两次，为什么](https://mp.weixin.qq.com/s/UEj2hQcoyhnu7CYGgR8OgA)
- [redis为什么把简单的字符串设计成SDS？](https://mp.weixin.qq.com/s/tsa3llfRlnrdBmlIXIuj3A)
- [一文搞定Redis五大数据类型及使用场景](https://mp.weixin.qq.com/s/JxkCGZI0P6xhzD1nv99Bvg)
- [Redis的8大数据类型，写得非常好！](https://mp.weixin.qq.com/s/9Tzw3zoNmePyUc3o9BHumQ)
- [美团二面：Redis5种基础数据结构？](https://mp.weixin.qq.com/s/SDde-hhB3DGXzmyb2n2x4A)


#### Redis的key过期策略


```
我们在set key的时候，可以给它设置一个过期时间，比如expire key 60。指定这key60s后过期，60s后，redis是如何处理的？我们先来介绍几种过期策略：一般有定时过期、惰性过期、定期过期三种。
定时过期
每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

惰性过期
只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

定期过期
每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。

Redis中同时使用了惰性过期和定期过期两种过期策略。
假设Redis当前存放30万个key，并且都设置了过期时间，如果你每隔100ms就去检查这全部的key，CPU负载会特别高，最后可能会挂掉。
因此，redis采取的是定期过期，每隔100ms就随机抽取一定数量的key来检查和删除的。但是呢，最后可能会有很多已经过期的key没被删除。这时候，redis采用惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且已经过期了，此时就会删除。
但是，如果定期删除漏掉了很多过期的key，然后也没走惰性删除。就会有很多过期key积在内存内存，直接会导致内存爆的。或者有些时候，业务量大起来了，redis的key被大量使用，内存直接不够了，运维也忘记加大内存了。难道redis直接这样挂掉？不会的！Redis用8种内存淘汰策略保护自己~
```
- [Redis过期key删除，那些不得不说的事情](https://mp.weixin.qq.com/s/iR8EgI9-p-BXjJEfTs3G7Q)
- [Redis的过期数据会被立马删除么？](https://mp.weixin.qq.com/s/qJt0B9p0GeUkekK15xL-jw)

#### Redis内存淘汰策略

```
volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；
allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。
volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU（最少访问算法）进行删除key。
allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；
volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。
allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；
noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。
```
- [Redis内存满了怎么办？](https://mp.weixin.qq.com/s/-kKe_ss01CkLMRERyyjt1Q)
- [内存耗尽后Redis会发生什么？](https://mp.weixin.qq.com/s/YqkVmIaDRV31-WrcW8K26g)


#### Redis持久化


```
AOF持久化
AOF（append only file）持久化，采用日志的形式来记录每个写操作，追加到AOF文件的末尾。Redis默认情况是不开启AOF的。重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。AOF是执行完命令后才记录日志的。为什么不先记录日志再执行命令呢？这是因为Redis在向AOF记录日志时，不会先对这些命令进行语法检查，如果先记录日志再执行命令，日志中可能记录了错误的命令，Redis使用日志回复数据时，可能会出错。正是因为执行完命令后才记录日志，所以不会阻塞当前的写操作。但是会存在两个风险：更执行完命令还没记录日志时，宕机了会导致数据丢失,AOF不会阻塞当前命令，但是可能会阻塞下一个操作。这两个风险最好的解决方案是折中
妙用AOF机制的三种写回策略(appendfsync)：
always:同步写回，每个子命令执行完，都立即将日志写回磁盘。
everysec:每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。
no:只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘。
always同步写回，可以基本保证数据不丢失，no策略则性能高但是数据可能会丢失，一般可以考虑折中选择everysec。如果接受的命令越来越多，AOF文件也会越来越大，文件过大还是会带来性能问题。日志文件过大怎么办呢？AOF重写机制！就是随着时间推移，AOF文件会有一些冗余的命令如：无效命令、过期数据的命令等等，AOF重写机制就是把它们合并为一个命令（类似批处理命令），从而达到精简压缩空间的目的。
AOF重写会阻塞嘛？AOF日志是由主线程会写的，而重写则不一样，重写过程是由后台子进程bgrewriteaof完成。
AOF的优点：数据的一致性和完整性更高，秒级数据丢失。
AOF的缺点：相同的数据集，AOF文件体积大于RDB文件。数据恢复也比较慢。

RDB
因为AOF持久化方式，如果操作日志非常多的话，Redis恢复就很慢。有没有在宕机快速恢复的方法呢，有的，RDB！RDB，就是把内存数据以快照的形式保存到磁盘上。和AOF相比，它记录的是某一时刻的数据，，并不是操作。什么是快照?可以这样理解，给当前时刻的数据，拍一张照片，然后保存下来。RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis重启的时候，通过加载dump.rdb文件来恢复数据。RDB触发机制主要有以下几种：
1.手动触发
save(同步，会阻塞当前redis服务器)bgsave(异步，redis执行fork操作创建子进程)
2.自动触发(save m n)m秒内数据集存在n次修改时，自动触发bgsave

RDB通过bgsave命令的执行全量快照，可以避免阻塞主线程。basave命令会fork一个子进程，然后该子进程会负责创建RDB文件，而服务器进程会继续处理命令。请求快照时，数据能修改嘛？Redis接入操作系统的写时复制技术（copy-on-write，COW）,在执行快照的同时，正常处理写操作。虽然bgsave执行不会阻塞主线程，但是频繁执行全量快照也会带来性能开销。比如bgsave子进程需要通过fork操作从主线程创建出来，创建后不会阻塞主线程，但是创建过程是会阻塞主线程的。可以做增量快照。
RDB的优点：与AOF相比，恢复大数据集的时候会更快，它适合大规模的数据恢复场景，如备份，全量复制等
RDB的缺点：没办法做到实时持久化/秒级持久化。
Redis4.0开始支持RDB和AOF的混合持久化，就是内存快照以一定频率执行，两次快照之间，再使用AOF记录这期间的所有命令操作。

如何选择RDB和AOF
如果数据不能丢失，RDB和AOF混用
如果只作为缓存使用，可以承受几分钟的数据丢失的话，可以只使用RDB。
如果只使用AOF，优先使用everysec的写回策略。

混合持久化
既然RDB与AOF持久化都存在各自的缺点，那么有没有一种更好的持久化方式？
接下来要介绍的是混合持久化。其实就是RDB与AOF的混合模式，这是Redis4之后新增的。
1、持久化方式
混合持久化是通过aof-use-rdb-preamble参数来开启的。它的操作方式是这样的，在写入的时候先把数据以RDB的形式写入文件的开头，再将后续的写命令以AOF的格式追加到文件中。这样既能保证数据恢复时的速度，同时又能减少数据丢失的风险。
2、文件恢复
那么混合持久化中是如何来进行数据恢复的呢？在Redis重启时，先加载RDB的内容，然后再重放增量AOF格式命令。这样就避免了AOF持久化时的全量加载，从而使加载速率得到大幅提升。

```

- [同样是持久化，竟然有这么大的差别！](https://mp.weixin.qq.com/s/SVbVwHOAwL1RX0fa-rYGxg)
- [如何让Redis更持久](https://mp.weixin.qq.com/s/G3ct5tWox5Qt4tLUDEpRuw)
- [Redis宕机，数据丢了](https://mp.weixin.qq.com/s/RxhaZFnMAf7bAgYUtTGLuA)
- [小伙用12张图讲明白了Redis持久化！](https://mp.weixin.qq.com/s/q7KEOA2Dy2Q5QpDX8FkPjg)
- [彻底理解Redis的持久化和主从复制](https://mp.weixin.qq.com/s/5IBOKcoBxVoGSMrn3vBGOw)


#### Redis高可用


```
哨兵
主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。
哨兵模式，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。
简单来说，哨兵模式就三个作用：
发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；
哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；
哨兵之间还会相互监控，从而达到高可用。

故障切换的过程是怎样的呢
假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。

哨兵的工作模式如下：
每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个PING命令。
如果一个实例（instance）距离最后一次有效回复PING命令的时间超过down-after-milliseconds选项所指定的值，则这个实例会被Sentinel标记为主观下线。如果一个Master被标记为主观下线，则正在监视这个Master的所有Sentinel要以每秒一次的频率确认Master的确进入了主观下线状态。当有足够数量的Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态，则Master会被标记为客观下线。在一般情况下，每个Sentinel会以每10秒一次的频率向它已知的所有Master，Slave发送INFO命令。
当Master被Sentinel标记为客观下线时，Sentinel向下线的Master的所有Slave发送INFO命令的频率会从10秒一次改为每秒一次，若没有足够数量的Sentinel同意Master已经下线，Master的客观下线状态就会被移除；若Master重新向Sentinel的PING命令返回有效回复，Master的主观下线状态就会被移除。

Cluster集群
哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩（下线）和扩容（上线）问题。集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。
```

- [Redis主库宕机如何快速恢复](https://mp.weixin.qq.com/s/PA31mNTzlQ2EGYEXfWagXQ)
- [Redis官方的高可用性解决方案](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494325&idx=1&sn=0458cd40672c1f3918efb47963e56c9c&source=41#wechat_redirect)
- [一文把Redis主从复制、哨兵、Cluster三种模式摸透](https://mp.weixin.qq.com/s/BPcis9rPiWosFid5w0M40A)
- [Redis主从、哨兵、Cluster集群一锅端！](https://mp.weixin.qq.com/s/U_5Tla4_XzlJsq3uRI2ifA)
- [Redis的主从复制是如何做的？复制过程中也会产生各种问题](https://mp.weixin.qq.com/s/I3GimkIf27DL1uRqxImKWA)
- [Redis中主、从库宕机如何恢复？](https://mp.weixin.qq.com/s/oRcOPBHwbimFak6CtooHEg)
- [Redis高可用篇：你管这叫主从架构数据同步原理？](https://mp.weixin.qq.com/s/NEUdCfRtHma3mkJqFKym5A)
- [如何从0到1构建一个稳定、高性能的Redis集群？](https://mp.weixin.qq.com/s/ZXz2IzbQjQJzCq_hkpkuEg)
- [4种Redis集群方案介绍+优缺点对比](https://mp.weixin.qq.com/s/Po85M418zvos3pHev2q0Tg)
- [详细剖析Redis三种集群策略](https://mp.weixin.qq.com/s/M1RymGVUqhQG0KnKupnDXQ)



#### 分布式锁

- [阿里面试官：分布式锁到底用Redis好？还是Zookeeper好？](https://mp.weixin.qq.com/s/5T0nrf5LBSqOiPd99OB3tw)
- [分布式锁用Redis还是Zookeeper？](https://mp.weixin.qq.com/s/_P3zWS1QzPdQp10Jb1bSOA)
- [Redis分布式锁到底安全吗](https://mp.weixin.qq.com/s/O9XZxwAcrCY-ninASw0I5Q)
- [Redis分布式锁深入探究](https://mp.weixin.qq.com/s/9SPMfKpv4iF_9m2F9ZTa3A)
- [七种方案！探讨Redis分布式锁的正确使用姿势](https://mp.weixin.qq.com/s/LTS3MKBU2FbRivXyQJcptA)
- [聊聊redis分布式锁的8大坑](https://mp.weixin.qq.com/s/vnVyvTeKvT_ZfMHr5_7CNg)
- [这才叫细：带你深入理解Redis分布式锁](https://mp.weixin.qq.com/s/yUH8jH9NTPLk24J_BQ0JfQ)
- [图解Redis分布式锁，写得太好了！](https://mp.weixin.qq.com/s/0GmtEI3DW-pCI21a1u10ng)
- [RedisTemplate分布式锁演变、Redission分布式锁实现](https://mp.weixin.qq.com/s/42AOUuTsYzt4nj69sqK0RA)
- [年轻人，看看Redisson分布式锁—可重入锁吧！太重要了](https://mp.weixin.qq.com/s/BlDsXWOcqpudORSiyI05Lg)
- [Redis分布式锁的正确实现原理演化历程与Redisson实战总结](https://mp.weixin.qq.com/s/PKGYoerpjWGeDzDE2iCFag)
- [从零到一编码实现Redis分布式锁](https://mp.weixin.qq.com/s/fwpHS07LcLLe82_cGOUxKA)
- [面试官问：Redis分布式锁如何自动续期？](https://mp.weixin.qq.com/s/x9YFF4QtHrCu3abSQHEL-A)
- [新来个技术总监，这Redis分布式锁设计的真漂亮！](https://mp.weixin.qq.com/s/NyGzKF2hZnS-6UnPxbFXcg)
- [lock4j:基于SpringAOP的声明式和编程式分布式锁，支持RedisTemplate、Redisson、Zookeeper](https://gitee.com/baomidou/lock4j)


#### 业务结合

- [手把手教你在学会Docker安装Redis镜像](https://mp.weixin.qq.com/s/XYwDWnQ6KFyPiClmngePQA)
- [Redis到底是怎么实现“附近的人”这个功能的呢？](https://mp.weixin.qq.com/s/HVJLoRqUulLyCoNvamBSgw)
- [SpringBoot+Redis：模拟10w人的秒杀抢单！](https://mp.weixin.qq.com/s/2hsjyUpDUqC4bVSAe36Gyw)
- [电商红包雨是如何实现的？](https://mp.weixin.qq.com/s/uehjf3EXb107Dy6wnO34qQ)
- [永远不要使用Redis过期监听实现定时任务](https://mp.weixin.qq.com/s/4bgQrYm4i7KdSLFKGvsOIA)
- [如何用Redis统计独立用户访问量？](https://mp.weixin.qq.com/s/oQXYKjKb0XqAJnO-m5uqOw)
- [面试官：Redis如何实现每周热评功能？说说思路！](https://mp.weixin.qq.com/s/Guq3NXRw-Bk60hElYiO0_w)


#### 命令

- ./redis-server /usr/local/redis/redis.conf
- ./redis-cli -h 127.0.0.1 -p 6379 -a 123456
- ./redis-cli -h 127.0.0.1 -p 6379 -a 123456 shutdown //关闭redis

- [Linux下载地址](https://download.redis.io/releases/)
- [windows下载地址](https://github.com/microsoftarchive/redis/tags)




#### 阿里官方Redis开发规范

```
一、键值设计
1、key名设计
可读性和可管理性
以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id - ugc:video:1
简洁性
保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。
不要包含特殊字符
反例：包含空格、换行、单双引号以及其他转义字符
2、value设计
拒绝bigkey
防止网卡流量、慢查询，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。
反例：一个包含200万个元素的list。
非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法
选择适合的数据类型
例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)
反例：
set user:1:name tomset user:1:age 19set user:1:favor football
正例：
hmset user:1 name tom age 19 favor football
控制key的生命周期
redis不是垃圾桶，建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。

二、命令使用
1、O(N)命令关注N的数量
例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。
2、禁用命令
禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。
3、合理使用select
redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。
4、使用批量操作提高效率
原生命令：例如mget、mset。非原生命令：可以使用pipeline提高效率。但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。
注意两者不同：原生是原子操作，pipeline是非原子操作。pipeline可以打包不同的命令，原生做不到,pipeline需要客户端和服务端同时支持。
5、不建议过多使用Redis事务功能
Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)
6、Redis集群版本在使用Lua上有特殊要求
①所有key都应该由KEYS数组来传递，redis.call/pcall里面调用的redis命令，key的位置，必须是KEYS array,否则直接返回error，"-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn"
②所有key，必须在1个slot上，否则直接返回error, "-ERR eval/evalsha command keys must in same slotrn"
7、monitor命令
必要情况下使用monitor命令时，要注意不要长时间使用。

三、客户端使用
1、避免多个应用使用一个Redis实例:不相干的业务拆分，公共数据做服务化。
2、使用连接池:可以有效控制连接，同时提高效率，标准使用方式：
执行命令如下：
Jedis jedis = null;
try {
    jedis = jedisPool.getResource();
    //具体的命令
    jedis.executeCommand()
} catch (Exception e) {
    logger.error("op key {} error: " + e.getMessage(), key, e);
} finally {
    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。
    if (jedis != null)
        jedis.close();
}

3、熔断功能:高并发下建议客户端添加熔断功能(例如netflix hystrix)
4、合理的加密:设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）
5、淘汰策略
根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。
默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。
其他策略如下：
allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
allkeys-random：随机删除所有键，直到腾出足够空间为止。
volatile-random:随机删除过期键，直到腾出足够空间为止。
volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。
noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作。

四、相关工具
1、数据同步:redis间数据同步可以使用：redis-port
2、big key搜索:redis大key搜索工具
3、热点key寻找
内部实现使用monitor，所以建议短时间使用facebook的redis-faina 阿里云Redis已经在内核层面解决热点key问题

五、删除bigkey
下面操作可以使用pipeline加速。
redis4.0已经支持key的异步删除，欢迎使用。
1、Hash删除: hscan + hdel
public void delBigHash(String host, int port, String password, String bigHashKey) {
    Jedis jedis = new Jedis(host, port);
    if (password != null && !"".equals(password)) {
        jedis.auth(password);
    }
    ScanParams scanParams = new ScanParams().count(100);
    String cursor = "0";
    do {
        ScanResult<Entry<String, String>> scanResult = jedis.hscan(bigHashKey, cursor, scanParams);
        List<Entry<String, String>> entryList = scanResult.getResult();
        if (entryList != null && !entryList.isEmpty()) {
            for (Entry<String, String> entry : entryList) {
                jedis.hdel(bigHashKey, entry.getKey());
            }
        }
        cursor = scanResult.getStringCursor();
    } while (!"0".equals(cursor));

    //删除bigkey
    jedis.del(bigHashKey);
}


2、List删除: ltrim
public void delBigList(String host, int port, String password, String bigListKey) {
    Jedis jedis = new Jedis(host, port);
    if (password != null && !"".equals(password)) {
        jedis.auth(password);
    }
    long llen = jedis.llen(bigListKey);
    int counter = 0;
    int left = 100;
    while (counter < llen) {
        //每次从左侧截掉100个
        jedis.ltrim(bigListKey, left, llen);
        counter += left;
    }
    //最终删除key
    jedis.del(bigListKey);
}

3、Set删除: sscan + srem
public void delBigSet(String host, int port, String password, String bigSetKey) {
    Jedis jedis = new Jedis(host, port);
    if (password != null && !"".equals(password)) {
        jedis.auth(password);
    }
    ScanParams scanParams = new ScanParams().count(100);
    String cursor = "0";
    do {
        ScanResult<String> scanResult = jedis.sscan(bigSetKey, cursor, scanParams);
        List<String> memberList = scanResult.getResult();
        if (memberList != null && !memberList.isEmpty()) {
            for (String member : memberList) {
                jedis.srem(bigSetKey, member);
            }
        }
        cursor = scanResult.getStringCursor();
    } while (!"0".equals(cursor));

    //删除bigkey
    jedis.del(bigSetKey);
}

4、SortedSet删除: zscan + zrem
public void delBigZset(String host, int port, String password, String bigZsetKey) {
    Jedis jedis = new Jedis(host, port);
    if (password != null && !"".equals(password)) {
        jedis.auth(password);
    }
    ScanParams scanParams = new ScanParams().count(100);
    String cursor = "0";
    do {
        ScanResult<Tuple> scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);
        List<Tuple> tupleList = scanResult.getResult();
        if (tupleList != null && !tupleList.isEmpty()) {
            for (Tuple tuple : tupleList) {
                jedis.zrem(bigZsetKey, tuple.getElement());
            }
        }
        cursor = scanResult.getStringCursor();
    } while (!"0".equals(cursor));
    //删除bigkey
    jedis.del(bigZsetKey);
}
```